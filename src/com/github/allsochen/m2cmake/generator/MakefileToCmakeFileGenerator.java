package com.github.allsochen.m2cmake.generator;

import com.github.allsochen.m2cmake.configuration.JsonConfig;
import com.github.allsochen.m2cmake.constants.Constants;
import com.github.allsochen.m2cmake.makefile.TafMakefileProperty;
import com.github.allsochen.m2cmake.utils.CollectionUtil;
import com.github.allsochen.m2cmake.utils.ProjectUtil;
import com.github.allsochen.m2cmake.utils.ProjectWrapper;
import com.github.allsochen.m2cmake.view.ConsoleWindow;
import com.intellij.execution.ui.ConsoleViewContentType;
import com.intellij.openapi.project.Project;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class MakefileToCmakeFileGenerator extends AbstractCmakeFileGenerator {

    private TafMakefileProperty tafMakefileProperty;
    private JsonConfig jsonConfig;
    private ConsoleWindow consoleWindow;

    public MakefileToCmakeFileGenerator(ProjectWrapper projectWrapper,
                                        TafMakefileProperty tafMakefileProperty,
                                        JsonConfig jsonConfig,
                                        ConsoleWindow consoleWindow) {
        super(projectWrapper);
        this.tafMakefileProperty = tafMakefileProperty;
        this.jsonConfig = jsonConfig;
        this.consoleWindow = consoleWindow;
    }

    /**
     * Filter the ../.. path and transfer to the real path.
     *
     * @param includePath
     * @return
     */
    private String transferIncludePath(String includePath) {
        if (!includePath.matches(".*[a-zA-z].*")) {
            return "";
        }
        return this.tafMakefileProperty.transferMapping(includePath, jsonConfig.getDirMappings());
    }

    public static File getCmakeListFile(String basePath) {
        return new File(basePath + File.separator + "CMakeLists.txt");
    }

    public void create() {
        Project project = projectWrapper.getProject();
        String app = projectWrapper.getApp();
        String target = projectWrapper.getTarget();
        try {
            File cmakeFile = getCmakeListFile(project.getBasePath());
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(
                    new FileOutputStream(cmakeFile), StandardCharsets.UTF_8));
            // Write header.
            bw.write("# This file is generated by TAF m2cmake plugin\n");
            bw.write("# http://www.github.com/allsochen/clion-m2cmake\n");
            bw.newLine();
            String cmakeVersion = "3.10";
            if (!jsonConfig.getCmakeVersion().isEmpty()) {
                cmakeVersion = jsonConfig.getCmakeVersion();
            }
            bw.write("cmake_minimum_required(VERSION " + cmakeVersion + ")");
            bw.newLine();

            bw.write("project(" + projectWrapper.getTarget() + ")");
            bw.newLine();
            bw.write("set(CMAKE_CXX_STANDARD 17)");
            bw.newLine();

            String cxxFlags = "-std=c++17 -Wno-narrowing -fno-strict-aliasing -Wno-deprecated-declarations -fPIC -Wno-deprecated -Wall";
            bw.write("set(CMAKE_CXX_FLAGS \"" + cxxFlags + "\")");
            bw.newLine();

            bw.newLine();
            bw.write("#配置include");
            bw.newLine();

            Set<String> configIncludes = new LinkedHashSet<>(this.jsonConfig.getIncludes());
            if (configIncludes != null) {
                for (String include : configIncludes) {
                    bw.write("include_directories(" + include + ")");
                    bw.newLine();
                }
            }

            bw.newLine();
            bw.write("#服务include");
            bw.newLine();
            Set<String> includes = new LinkedHashSet<>(this.tafMakefileProperty.getIncludes());
            for (String include : includes) {
                include = transferIncludePath(include);
                if (include != null && !include.isEmpty()) {
                    bw.write("include_directories(" + transferIncludePath(include) + ")");
                    bw.newLine();
                }
            }
            bw.newLine();

            bw.write("#服务jce依赖");
            bw.newLine();
            bw.write("include_directories(./)");
            bw.newLine();
            String tafJceDepend = ProjectUtil.getLocalTafjceDependenceDir(jsonConfig, target)
                    .replaceAll("\\\\", "/");
            bw.write("include_directories(" + tafJceDepend + ")");
            bw.newLine();

            List<String> localDir = new ArrayList<>();
            localDir.add(jsonConfig.getTafjceLocalDir());
            List<String> jceIncludeFilePaths = this.tafMakefileProperty.getJceDependenceRecurseIncludes(
                    localDir, true);
            // Add itself
            jceIncludeFilePaths.add(Constants.HOME_TAFJCE + "/" + app + "/" + target);
            jceIncludeFilePaths = CollectionUtil.uniq(jceIncludeFilePaths);
            Collections.sort(jceIncludeFilePaths);
            for (String include : jceIncludeFilePaths) {
                if (include != null && !include.isEmpty()) {
                    String dependenceLocalIncludePath = tafMakefileProperty.toLocalIncludePath(include,
                            jsonConfig.getDirMappings());
                    bw.write("include_directories(" + dependenceLocalIncludePath + ")");
                    bw.newLine();
                }
            }
            bw.newLine();

            bw.write("file(GLOB_RECURSE CMAKE_FILES *.c *.cc *.cpp *.h)");
            bw.newLine();
            bw.write("add_executable(" + target + " ${CMAKE_FILES})");
            bw.newLine();
            bw.flush();
            bw.close();
            cmakeFile.setLastModified(System.currentTimeMillis());
            consoleWindow.println("", ConsoleViewContentType.NORMAL_OUTPUT);
            consoleWindow.println("Transfer TAF makefile to CMakeList finished.",
                    ConsoleViewContentType.ERROR_OUTPUT);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
